Часова складність алгори́тму — характеристика продуктивності алгоритму, що визначається кількістю елементарних 
операцій, які потрібно виконати для реалізації алгоритму.

Основним метрикою для вимірювання часової складності є кількість операцій (чи кроків) алгоритму, необхідних для
завершення обчислень. Зазвичай цю кількість операцій виражають як функцію від розміру вхідних даних, наприклад, 
як O(n), де n - це розмір вхідних даних.

Основний принцип визначення часової складності - це аналіз того, як змінюється кількість операцій при збільшенні 
розміру вхідних даних. Часова складність може бути різною для різних алгоритмів, які розв'язують одну і ту ж проблему, 
і є важливою властивістю при виборі алгоритму для вирішення конкретної задачі.

Наприклад, якщо у нас є алгоритм сортування, то часова складність може бути виражена, скажімо, як O(n log n), де n - 
це кількість елементів, які потрібно відсортувати. Це означає, що кількість операцій, необхідних для сортування, 
зростає приблизно логарифмічно зі збільшенням розміру масиву.

Отже, часова складність допомагає в зрозумінні того, наскільки ефективно або неефективно працює алгоритм при 
збільшенні розміру вхідних даних і дозволяє нам зробити відповідні висновки щодо його використання у практичних застосуваннях.

O(1): Це константна складність, де час виконання алгоритму не залежить від обсягу вхідних даних. Наприклад, доступ до елементу масиву за індексом.

O(log n): Логарифмічна складність, де час виконання зростає логарифмічно з обсягом вхідних даних. Наприклад, бінарний пошук в відсортованому масиві.

O(n): Лінійна складність, коли час виконання зростає лінійно з обсягом вхідних даних. Наприклад, ітерація по масиву для пошуку конкретного елемента.

O(n log n): Складність, характерна для багатьох ефективних алгоритмів сортування, таких як швидке сортування(Quicksort) та злиття(Merge sort).

O(n^2): Квадратична складність, коли час виконання зростає квадратично з обсягом вхідних даних. Наприклад, сортування вибором.

O(2^n): Експоненціальна складність, де час виконання зростає експоненціально з обсягом вхідних даних. Наприклад, задачі комбінаторики або рекурсивні алгоритми з великою глибиною рекурсії.
